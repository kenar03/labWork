= Лабораторная работа №2
Долгов К.М. <КЭ-413>
:description: Лабораторная работа №2
:toc:
:toc-title: Оглавление
:figure-caption: Рисунок
:table-caption: Таблица
:imagesdir: images_lab2

== Типы данных

.Типы данных в C++
image::data_types.png[]

В языке C++ типы данных делятся на следующие категории:

. простые (включают целые типы и типы с плавающей точкой);
. структурированные;
. адресные.

В таблице 1 представлены основные используемые в IAR Workbench типы данных и их размеры.

[#Встроенные типы С++]
.Встроенные типы С++
[options="header"]
[cols="2,1,7"]
|=====================
|Тип | Длина |Комментарий
|*bool*| 1| Представляет значения, которые могут быть или *true*, или *false*.
|*char*|1	| Используется для символов ASCII в старых строках в стиле C или в объектах std::string,
которые никогда не будут преобразовываться в Юникод.
|*unsigned char*| 1 |	Аналог байта. В С++17 стандарте появился тип std::byte
|*int*|	4 |Целочисленное значение. Выбор по умолчанию для целых чисел
|*unsigned int*| 4| Беззнаковое целое число
|*float*| 4	|Число с плавающей точкой, поддерживается аппаратно некоторыми микроконтроллерами
|*double*| 8	|Число с плавающей запятой двойной точности. Выбор по умолчанию для значений с плавающей
точкой
|=====================

В таблице 2 представлены основные модификаторы типов данных.

[#Встроенные типы С++ модификаторы]
.Встроенные типа С++ модификаторы
[options="header"]
[cols="2,1, 7"]
|=====================
|Тип | Длина |Комментарий
|*short int*|	2|Целочисленное знаковое значение укороченной длины
|*unsigned short int*| 2|	Целочисленное беззнаковое значение укороченной длины
|*long int*|	8|Выбор по умолчанию для целочисленных значений. На платформах на которых int равен по
длине unsigned short int может быть длиннее int
|*unsigned long int*|8	|Целое число двойной длины. На платформах на которых int равен по длине unsigned short int может быть
длиннее int
|*long double*|8	|Число с плавающей точкой двойной точности	с двойной точностью 
|=====================

=== Смешивание типов

Типы данных в C++ нельзя смешивать, так как это может привести к различного рода ошибкам. Так, например, при неявном преобразовании одного типа данных к другому возможна потеря данных (отбрасывается дробная часть).
Также при неявном приведении больших типов к меньшим возможно переполнение типа данных. В целом, смешивания типов данных следует избегать, так как оно может привести не только к потере данных или переполению, но и к неопределенному поведению программы в целом.

=== Неявное преобразование типов

Неявное преобразование - это автоматическое преобразование компилятором одного типа данных в другой без явного на то указания. Компилятор автоматические выполняет преобразование, если видит, что типы данных друг с другом не совместимы.
Как было сказано ранее, неявного преобразования типов следует избегать, поскольку могут возникать различного рода ошибки, а именно: потеря части данных, переполнение типа данных, или вообще, аварийное завершение работы программы.

=== Явное преобразование типов

Если создатель программы уверен, что один тип в другой преобразовать необходимо, он может воспользоваться явным преобразованием типов.

Явное преобразование - это процесс преобразования одного типа в другой, которе указывается программистом явно, т.е. путем прямого указания операции преобразования типа в коде.

Используется явное преобразование для того, чтобы контролировать процесс преобразования данных, показывать, в каких ситуациях и как эти типы нужно преобразовывать.
Кроме того, явное преобразование говорит о ясности намерений разработчика: прямое явное указание компилятору операции преобразования типа позволяет уменьшить количество ошибок при работе программы.

=== Размеры типов данных

В микроконтроллерах размер одного и того же типа данных определены не четко и могут быть различны. Если в коде создать переменную типа *unsigned int*, то ее размер в зависимости от конфигурации микрконтроллера и компилятора может быть различен.
Так, например, в IAR Workbench можно создавать переменные типа *uint*, но при создании такой переменной следует указывать размер типа.
Беззнаковый целочисленный тип может быть представлен как *uint8_t* (1 байт), *uint16_t* (2 байта), *uint32_t* (4 байта), *uint64_t* (8 байт). Если размер переменной не указать, то программа может вести себя непредсказуемо.

Размеры целочисленных типов представлены на рисунке 2.

.Размеры целочисленных типов
image::fixed_type_length.jpg[]

Что касается втроенных типов (см. <<Таблица 1>>), их использование не рекомендуется именно из-за того, что их размер не предсказуем и варьируется в зависимости от используемого микроконтроллера и компилятора.
Всегда следует указывать не только тип, но и его размер.

=== Функции преобразования типов

Ранее уже говорилось о явном преобразовании типов. Для того, чтобы провести явное преобразование, существуют специальные функции.

==== Функция static_cast

Функция *static cast* позволяет сделать приведение близких типов (целые, пользовательских типов которые могут создаваться из типов который приводится, и указатель на void* к указателю на любой тип).

.Пример использования *static_cast*
[source, cpp]
----
int a = 42;
void* ptr = static_cast<void*>(&a);  // Преобразование указателя int* в void*
int* intPtr = static_cast<int*>(ptr);  // Обратное преобразование void* в int*
----

==== Функция reinterpret_cast

Данная функция преобразует типы, не совместимые друг с другом.

*reinterpret_cast* может использоваться для преобразования указателей между различными типами, например, для преобразования указателя на один тип в указатель на другой тип.
Однако, преобразование с помощью функции *reinterpret_cast* зачастую является небезопасным, так как в отличие от *static_cast*, *reinterpreted_cast* не выполняет никаких проверок безопасности, что может привести к неопределенному поведению программы.

== Память микркоконтроллера

=== Распределение памяти ОЗУ в микроконтроллере

Память ОЗУ в микроконтроллере распределяется на следующие сегменты:

. Стек - используется для хранения временных данных (адреса возврата из прерываний, локальные переменные).
. Куча - используется для динамического распределения памяти во время работы программы. Хранит в себе объекты и данные, размер которых заранее не известен. В отличие от стека, память в куче управляется вручную.
. Глобальные и статические переменные - выделяются в ОЗУ и инициализируются на этапе компиляции.

Вся память микроконтроллера имеет 4 Гбайта последовательной памяти с адресами от 0x00000000 до 0xFFFFFFFF.

Адресное пространство памяти программы (ПЗУ) находится по адресам 0x00000000 по 0x1FFFFFFF

Адресное пространство ОЗУ находится по адресам 0x20000000 по 0x3FFFFFFF

Адресное пространство для регистров периферии находится по адресам с 0x40000000 по 0x5FFFFFFF.

=== Указатели

Каждый адрес памяти микроконтроллера может содержать в себе какие-либо данные.

Указатель - это переменная, содержащая в себе адрес другой переменной.

Указатель можно создать с помощью оператора *&*. Разыменовывание указателя - операция, обратная взятию указателя - производится с помощью знака ***.

[source, cpp]
----
int c = 450;
int* variable = &c;
----

С указателем можно совершать различные операции. Их можно складывать, вычитать, сравнивать, но при условии, что они являются однотипными.
То есть, нельзя производить операции над указателями различных типов, например, нельзя сложить указатели *char** и *int**.

С помощью указателей можно изменить содержимое ячейки памяти. Приведу пример:

[source, cpp]
----
int x = 10;     (1)
int* ptr = &x;  (2)
*ptr = 20;      (3)
----

. Создается переменная *x*, в которой хранится значение 10.
. Создается указатель *ptr*, содержащий в себе адрес переменной *x*.
. Изменяется содержимое переменной *x* (теперь x=20).

=== Регистры

Регистр - это особый вид памяти внутри микроконтроллера, который используется для управления процессором и периферийными устройствами. Он представляет собой ячейку памяти и имеет длину в 32 бита.

Поменять значение регистра можно напрямую с помощью указателя. Для этого необходимо указать адрес регистра и записать в указатель на адрес регистра необходимое значение:

=== Логические операции

Дизъюнкция - логическое сложение. Результат дизъюнкции равен единице, если хотя бы одно слагаемое равно единице. Примеры: 1 | 0 = 1; 0 | 0 = 0;

Конъюнкция - логическое умножение. Ее результат равен 1, когда оба множителя равны 1. Примеры: 1 & 0 = 0; 1 & 1 = 1.

=== Сброс бита

Бит можно сбросить с помощью маски с применением побитовых операций.

.Сброс бита
[source, cpp]
----
unsigned int x = 15;
int n = 1;
x &= ~(1 << n);
----

В данном примере n - это номер бита, (1 << n) - битовая маска.

Число 15 в двоичной системе: 0000 1111
Маска: 0000 0001

Поскольку бит необходимо сбросить, маска инвертируется, а сама операция сброса выполняется с помощью операции конъюнкции.
Так: 0000 1111 & 1111 1110 = 0000 1110. Стоит учитывать, что для сброса бита необходимо использовать побитовое "И", а не логическое.


[source, cpp]
----
std::uint32_t* reg_ptr = reinterpret_cast<std::uint32_t*>(0x40021000);
*reg_ptr = 0x01;
----

В данном примере в регистр с адресом 0x40021000 записывается значение 1.
== Ответы на вопросы

[qanda]
Если указатель типа Int указывает на адрес 1 и к этому указателю прибавить 1, то на какой адрес будет указывать указатель и почему? А если указатель будет типа double?::

Ответ:
При прибавлении к указателю числа, прибавляется не само число, а его значение, перемноженное на размер типа данных указателя. Так, при прибавлении к указателю типа int единицы его значение станет равным *1+4=5*, поскольку размер типа int - 4 байта. Если указатель будет типа double, то после прибавления единицы указатель станет равен 1+8=9, т.к. размер типа double - 8 байтов.

Если в ячейке по адресу 1 лежит число 10, в ячейке по адресу 2 лежит число 20, в ячейке по адресу 3 лежит число 30, в ячейке по адресу 4 лежит число 40 и если у нас указатель типа std::uint32_t указывает на адрес 1, то какое число будет в переменной b после разыменовывания указателя?::

Ответ: поскольку указатель типа uint32_t, а его размер 4 байта, при разыменовывании указателя из памяти будет взято четыре близлежащих байта, то есть адреса 1, 2, 3, 4. Переведем значения, хранящиеся в адресах 1, 2, 3 и 4 в 16-ю систему счисления. 10 = 0x0A, 20 = 0x14, 30 = 0x1E, 40 = 0x28. Адреса располагаются в порядки от младшего к старшему, то есть: 0x28 0x1E, 0x14, 0x0A. Получится 32-битное число формата uint32_t=0x281E140A. В десятичной системе 0x281E140A = 673059850. Таким образом, b = 673059850.

std::uint32_t ptr* = reinterpret_cast<std::uint32_t*>(1);::
auto b = *ptr; //чему равно b?::

Ответ: b будет равно значению указателя ptr на адрес 1.

std::uint16_t* ptr = reinterpret_cast<std::uint16_t*>(1);::
auto b = *ptr; //чему равно b?::

Ответ: b будет равно значению указателя ptr на адрес 1.

auto b = "c";  //Какого типа b?::
auto b1 = 'c'; //Какого типа b1::
char a = 'A';  //В какое число переведется символ А::

Ответ: переменная b будет иметь типа указателя на константный массив символов (const char*). Если необходимо получить именно строковый тип, то следует изменить выражение следующим образом:

[source, cpp]
----
auto b = std::string("c");
----

Переменная b1 будет иметь символьный тип (char).

Символ А в кодировке ASCII имеет значение 65 (0x41 в 16-й системе). Следовательно, он переведется в число 65.