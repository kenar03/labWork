= Лабораторная работа №3,4
Долгов К.М. <КЭ-413>
:description: Лабораторная работа №3,4
:toc:
:toc-title: Оглавление
:figure-caption: Рисунок
:table-caption: Таблица
:imagesdir: lab3_4_images

== Включение светодиодов с помощью указателей

В ходе лекции выполнялось задание, суть которого заключалась в том, чтобы зажигать светодиоды "елочкой", т.е. последовательно, от LED1 до LED4 включать светодиоды, а затем, после того как все светодиоды активны, в таком же порядке выключать их.

Самый простой способ решения данной задачи - установка бита на нужном адресе. Установка бита осуществляется с помощью битовой маски.

Светодиоды расположены на двух портах (GPIOA и GPIOC). На порте GPIOC расположены 3 светодиода (бит 5, 8 и 9), а на порте GPIOA - 1 светодиод (бит 5):

[source, cpp]
----
// Битовые маски
const std::uint32_t maskBit5 = (1U << 5U);
const std::uint32_t maskBit8 = (1U << 8U);
const std::uint32_t maskBit9 = (1U << 9U);

// Указание адресов портов
std::uint32_t* const prtGpiocOdr = reinterpret_cast<uint32_t*>(0x40020814U); // Порт GPIOC
std::uint32_t* const prtGpioaOdr = reinterpret_cast<uint32_t*>(0x40020014U); // Порт GPIOA

for(;;)
{
    // Включение светодиодов
    *prtGpioaOdr |= maskBit5; // Светодиод LED1
    delay(1000000);

    *prtGpiocOdr |= maskBit9; // Светодиод LED2
    delay(1000000);

    *prtGpiocOdr |= maskBit8; // Светодиод LED3
    delay(1000000);

    *prtGpiocOdr |= maskBit5; // Светодиод LED4
    delay(1000000);

    // Выключение светодиодов
    *prtGpioaOdr &= ~maskBit5; // Светодиод LED1
    delay(1000000);

    *prtGpiocOdr &= ~maskBit9; // Светодиод LED2
    delay(1000000);

    *prtGpiocOdr &= ~maskBit8; // Светодиод LED3
    delay(1000000);

    *prtGpiocOdr &= ~maskBit5; // Светодиод LED4
    delay(1000000);
}
----

<<Данный код>> последовательно зажигает светодиоды LED1-LED4, а затем последовательно гасит их в том же порядке.

Включение светодиода производится путем применения операции побитового ИЛИ к значению, хранящемуся в адресе и к битовой маске. Выключение светодиода происходит путем применения операции побитового И к значению в адресе и к инвертированной битовой маске.

[IMPORTANT]
====
Несмотря на то, что данный код решает конкретную задачу, он не является универсальным
====

Для того, чтобы расширить область применения кода, а также упростить его дальнейшее редактирование и использование, прибегнем к другому способу реализации - созданию класса.