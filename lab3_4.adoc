= Лабораторная работа №3,4
Долгов К.М. <КЭ-413>
:description: Лабораторная работа №3,4
:toc:
:toc-title: Оглавление
:figure-caption: Рисунок
:table-caption: Таблица
:imagesdir: lab3_4_images

== Принцип Single Responsibility

Принцип Single Responsibility гласит, что в объектно-ориентированном программировании каждый объект или модуль в программе должен иметь одну конкретную обязанность.

Напирмер, существует необходимость создания программы, которая управляет светофором на перекрестке. В данном случае за включение сигнала светофора и за переключение его цвета должны отвечать разные объекты. Если же один объект будет отвечать за включение сигнала и его переключение, то принцип будет нарушен.

== Включение светодиодов с помощью указателей

В ходе лекции выполнялось задание, суть которого заключалась в том, чтобы зажигать светодиоды "елочкой", т.е. последовательно, от LED1 до LED4 включать светодиоды, а затем, после того как все светодиоды активны, в таком же порядке выключать их.

Самый простой способ решения данной задачи - установка бита на нужном адресе. Установка бита осуществляется с помощью битовой маски.

Светодиоды расположены на двух портах (GPIOA и GPIOC). На порте GPIOC расположены 3 светодиода (бит 5, 8 и 9), а на порте GPIOA - 1 светодиод (бит 5):

[source, cpp]
----
// Битовые маски
const std::uint32_t maskBit5 = (1U << 5U);
const std::uint32_t maskBit8 = (1U << 8U);
const std::uint32_t maskBit9 = (1U << 9U);

// Указание адресов портов
std::uint32_t* const prtGpiocOdr = reinterpret_cast<uint32_t*>(0x40020814U); // Порт GPIOC
std::uint32_t* const prtGpioaOdr = reinterpret_cast<uint32_t*>(0x40020014U); // Порт GPIOA

for(;;)
{
    // Включение светодиодов
    *prtGpioaOdr |= maskBit5; // Светодиод LED1
    delay(1000000);

    *prtGpiocOdr |= maskBit9; // Светодиод LED2
    delay(1000000);

    *prtGpiocOdr |= maskBit8; // Светодиод LED3
    delay(1000000);

    *prtGpiocOdr |= maskBit5; // Светодиод LED4
    delay(1000000);

    // Выключение светодиодов
    *prtGpioaOdr &= ~maskBit5; // Светодиод LED1
    delay(1000000);

    *prtGpiocOdr &= ~maskBit9; // Светодиод LED2
    delay(1000000);

    *prtGpiocOdr &= ~maskBit8; // Светодиод LED3
    delay(1000000);

    *prtGpiocOdr &= ~maskBit5; // Светодиод LED4
    delay(1000000);

    return 1;
}
----

<<Данный код>> последовательно зажигает светодиоды LED1-LED4, а затем последовательно гасит их в том же порядке.

Включение светодиода производится путем применения операции побитового ИЛИ к значению, хранящемуся в адресе и к битовой маске. Выключение светодиода происходит путем применения операции побитового И к значению в адресе и к инвертированной битовой маске.

[IMPORTANT]
====
Несмотря на то, что данный код решает конкретную задачу, он не является универсальным
====

Для того, чтобы расширить область применения кода, а также упростить его дальнейшее редактирование и использование, прибегнем к другому способу реализации - созданию класса.

== Включение светодиодов с помощью класса

Для решения данной задачи можно использовать класс. По сути класс - это некая абстракция объекта, которая говорит, что это за объект и какие действия он может делать.

Создадим класс обекта светодиод "Led":

[source, cpp]
----
// Создание виртуального класса
class ILed
{
    virtual void Light() = 0;
    virtual void Off() = 0;
    virtual void Toggle() = 0;
};

// Создание класса Led
class Led : public ILed
{
public:
    Led(std::uint32_t registerAddres, std::uint32_t pinNumber) : 
    registerAddr(registerAddres), pinNum(pinNumber) // Конструктор
    {
    }

    void Light() override // Функция включения светодиода
    {
        *reinterpret_cast<std::uint32_t*>(registerAddr) |= (1 << pinNum);
    }
    void Off() override // Функция выключения светодиода
    {
        *reinterpret_cast<std::uint32_t*>(registerAddr) &= ~(1 << pinNum);
    }
    void Toggle() override // Функция изменения состояния светодиода на противоположное
    {
        *reinterpret_cast<std::uint32_t*>(registerAddr) ^= (1 << pinNum);
    }
private:
    std::uint32_t registerAddr; // Адрес указываемого регистра (порта)
    std::uint32_t pinNum; // Номер указываемого номера бита
};
----

Класс содержит в себе конструктор, показывающий, какие входные аргументы может иметь объект класса, а также
методы класса, а именно - включение светодиода, выключение и переключение в противоположное состояние.

Так, класс позволяет повторять аналогичные действия раз за разом, меняя лишь входные аргументы объекта и указывая метод класса.

Далее класс можно использовать для решения той же самой задачи - включения/выключения свтодиодов в нужном порядке.

[NOTE]
Укажем все светодиоды в виде массива для удобства

Решим задачу с "зажиганием" светодиодов "елочкой":

[source, cpp]
----
// Битовые маски
constexpr std::uint32_t maskBit5 = (1U << 5U);
constexpr std::uint32_t maskBit8 = (1U << 8U);
constexpr std::uint32_t maskBit9 = (1U << 9U);
// Указание портов
constexpr std::uint32_t gpiocOdrRegAddres = 0x40020814U;
constexpr std::uint32_t gpioaOdrRegAddres = 0x40020014U;
// Указатели
auto const gpioaOdrPtr = reinterpret_cast<std::uint32_t*>(gpioaOdrRegAddres);
auto const gpiocOdrPtr = reinterpret_cast<std::uint32_t*>(gpiocOdrRegAddres);

// Указание элементам массива (светодиодам) порта и бита
Led led1(gpioaOdrRegAddres, 5);
Led led2(gpiocOdrRegAddres, 9);
Led led3(gpiocOdrRegAddres, 8);
Led led4(gpiocOdrRegAddres, 5);

// Создание массива светодиодов
std::array<Led*, 4> leds = {
    &led1,
    &led2,
    &led3,
    &led4};

for(;;)
{
    for(auto it: leds)
    {
        it->Toggle(); // Включение/выключение светодиода
        delay(1000000);
    }
    
    return 1;
}
----

Таким образом, громоздкий код, который был создан в <<самом начале>> лабораторной работы, был сокращен
до двух строчек кода, выполняющих ту же самую функцию. Кроме того, такой код гораздо проще редактировать и расширять область его применения.

== Реализация других режимов включения светодиодов

В ходе лабораторной работы были также рассмотрены другие варианты включения светодиодов: *"елочкой" (уже разобран), все одновременно и в шахматном порядке.*

Таким образом, возникает еще одна задача: помимо указания порта и бита светодиода необходимо также указывать режим их работы.

Построим UML-диаграмму, показывающую обновленную структуру программы.

.UML-диаграмма
image::UML.jpg[]

На диаграмме показано, что функции включения/выключения светодиода (*Light, Off, Toggle*) реализованы с помощью отдельного класса (интерфейса). То есть, функции включения/выключения реализованы отдельно, что соответствует принципу *Single Responsibility*. В свою очередь, режимы работы светодиодов имеют два метода: обновление (*Update()*) и установление (*Init()*). Каждый из этих методов реализован отдельно в соответствующих классах режимов.

=== Светодиоды в шахматном порядке

Суть задания в том, что светодиоды необходимо зажигать попеременно, т.е. два горят, два не горят.

Поскольку каждый из создаваемых режимов имеет две основные функции: обновление и установление, следует создать виртуальный класс, объявляющий данные методы:

[source, cpp]
----
class IMode
    {
      virtual void Update() = 0; // Обновление режима
      virtual void Init() = 0; // Установление режима
    };
----

Далее можно приступить к реализации класса, включающего светодиоды в шахматном порядке (класс *ChessMode*).

[source, cpp]
----
using tLeds = std::array<ILed*, 4>; // Создание массива указателей на объекты виртуального класса

class ChessMode: public IMode
    {
    public:
      ChessMode(tLeds& ledsArr): leds(ledsArr)
      {
      }
      // Метод обновления режима
      void Update() override
      {
        for(auto it: leds)
        {
          it->Toggle();
        }
      }
      
      // Метод установления режима
      void Init() override
      {
        for(auto it: leds)
        {
          it->Light();
        }
        for(auto i=0; i< leds.size(); ++i)
        {
          if ((i%2)==0) // Условие четности
          {
            leds[i]->Toggle();
          }
        }
      }
    private:
      tLeds& leds;
    };
----

[IMPORTANT]
Виртуальный класс *IMode* был создан для того, чтобы функции обновления и установления режимов можно было переопределять для других режимов.

Иными словами, благодаря виртуальному классу, методы, по сути выполняющие одни и те же функции, могут быть применены для многих других создаваемых режимов.

=== Одновременное включение светодиодов

Реализуем другой режим работы светодиодов, позволяющий зажигать светодиоды одновременно и одновременно выключать их.

[source, cpp]
----
class AllMode:public IMode
 {
 public:
    AllMode(tLeds& ledsArr): leds(ledsArr)
    {
        
    }
      void Update() override
      {
        for(auto it: leds)
        {
          it->Toggle();
        }
      }
      
      void Init() override
      {
        for(auto it: leds)
        {
          it->Light();
        }
        
      }
private:
 tLeds& leds;
 };
----

=== Светодиоды в режиме "елочки"

Наконец, реализуем режим работы светодиодов "елочкой", рассмотренный ранее.

[source, cpp]
----
class TreeMode:public IMode
 {
 public:
    TreeMode(tLeds& ledsArr): leds(ledsArr)
    {
        
    }
      void Update() override
      {
         for(auto it: leds)
        {
          it->Light();
        }
        for(auto i=0; i< leds.size(); ++i)
        {
            leds[i]->Toggle();
        }
      }
        void Init() override
      {
        for(auto it: leds)
        {
          it->Light();
        }
        for(auto i=0; i< leds.size(); ++i)
        {
            leds[i]->Toggle();
        }
      }
    private:
      tLeds& leds;
    };
----

Таким образом, с помощью классов можно исполнять программу таким образом, что она становится понятной и легко редактируемой.