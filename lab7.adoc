= Лабораторная работа №7
Долгов К.М. <КЭ-413>
:description: Лабораторная работа №7
:toc:
:toc-title: Оглавление
:figure-caption: Рисунок
:table-caption: Таблица
:imagesdir: lab7_images
:important-caption: ВАЖНО!
:note-caption: ЗАМЕЧАНИЕ

include::lab7_titul.adoc[]

Таймер в микроконтроллере - это аппаратурный периферийный модуль, предназначенный, в основном, для отсчитывания точных интервалов времени. Однако, на деле область применения таймеров достаточно широка. Они используются для:

* измерения точных интервалов времени;
* измерения частоты / периодов;
* генерации широтно-импульно модулированного (ШИМ) сигнала;
* генерации сигналов различной формы.

В микроконтроллере STM32F411RET6 имеются следующие таймеры:

.Таймеры
[cols="a, a"]
|===
|Таймер | Описание

|TIM1
|Расширенный 16 битный таймер

|TIM2-TIM5
|Таймеры общего назначания. (TIM2 и TIM5 32 битные) (TIM3 и TIM4 16 битные)

|TIM9-TIM11
|Простые 16 битные таймеры.

|SYSTEM TIMER
|Системный таймер *SysTick*

|===

== Системный таймер

Системный таймер встроен в ядро ARMv7 и является 24-битным таймером, считывающим вниз от заданного значения до нуля.

Натройка системного таймера осуществляется с помощью трех регистров:

. SysTick Control and Status Register (SYST_CSR).
. Регистр перезагружаемого значения LOAD.
. Регистр текущего значения VAL.

=== Управление системным таймером

==== SysTick Control and Status Register (SYST_CSR)

Регистр SYST_CSR осуществляет управление системным таймером.

.Регистр SYST_CSR
image::register_SYST_CSR.png[]

.Поля регистра SYST_CSR
[cols="a, a, a,  7"]
|===
|Биты |Доступ |Обозначение |Описание

| 31:17
|
|
| Зарезервировано

| 16
| Read/Rewrite
| COUNTFLAG
| Показывает, дошёл ли счётчик до нуля с момента последнего считывания этого регистра:

*NoOverflow* (0) — счётчик ещё не достигал нуля

*Overflow* (1) — счётчик достигал нуля

Этот бит сбрасывается считыванием данного регистра, а также записью значения в регистр SYST_CVR. Его установка производится, когда значение cчётчика переходит из 1 в 0

| 15:3
|
|
|Зарезервировано

| 2
| Read/Write
| CLKSOURCE
| Выбирает источник синхронизации для таймера:

*ExternalClock*(0) — используется внешний источник

*CpuClock* (1) — для синхронизации используется частота процессора


| 1
| Read/Write
| TICKINT
| Определяет, будет ли генерироваться запрос на прерывание при достижении счетчиком 0:

*DisableInterrupt* (0) — запрос прерывания не выдаётся

*EnableInterrupt* (1) — запрос прерывания выдаётся

Достижением нуля считается только декремент значения счётчика, приводящий к появлению в нём нуля, но не его сброс в результате явной записи в регистр SYST_CVR

| 0
| Read/Write
| ENABLE
| Определяет, разрешена ли работа таймера (уменьшение счётчика):

*Disable*(0) — счётчик выключен

*Enable* (1) — счётчик включён

|===

==== Регистр перезагружаемого значения LOAD

Регистр *LOAD* представляет собой 32-битный регистр, в котором используются только первые 24 бита. В нем хранится значение, которое будет записано в системный таймер, как только его счетчик достигнет 0.

==== Регистр текущего значения VAL

Регистр *VAL* - это 32-битный регистр, в котором используется только первые 24 бита. В нем хранится текущее значение счетчика.

=== Алгоритм работы с системным таймером

С помощью системного таймера можно задавать практически любое значение задержки.

Алгоритм работы с таймером следующий:

* Записать в регистре LOAD значение задержки. Так как счетчик системного таймера уменьшается на 1 с каждым тактом процессора, то нетрудно посчитать, что если системная частота микроконтроллера подключена к внутренней источнику тактирования HSI, то для создания задержки в 1мс, необходимо записать в этот регистр значение (16'000'000/1000 - 1). Счетчик начнет уменьшаться с этого значения на 1 с каждым тактом процессора, и как только он дойдет до 0 установится флаг прерывания в региcтре ICSR в поле PENDSTSET (26 бит) 1.
* Записать в текущее значение счетчика в регистр VAL - 0.
* Подключить системный таймер к частоте процессора в регистре CTRL.
* Включить системный таймер в регистре CTRL.
* Дождаться готовности флага PENDSTSET в регистре ICSR.

=== Реализация алгоритма

Реализуем данный алгоритм, используя в качестве источника тактирования внутренний генератор 16 МГц.

[[delay_func]]
[source,cpp]
----
#include "rccregisters.hpp" // for RCC
#include "gpioaregisters.hpp" // for GPIOA
#include  "gpiocregisters.hpp" // for GPIOС
#include "stkregisters.hpp" // for SystemTimer
#include "scbregisters.hpp" // for ISCR register

#include "Led.h"
#include "allMode.h"
#include "chessMode.h"
#include "treeMode.h"
#include "LedConfig.h"
#include "ModesConfig.h"
#include "Button.h"
#include "ModeManager.h"

std::uint32_t SystemCoreClock = 16'000'000U;

extern "C" {
  
  int __low_level_init(void)
  {    
    RCC::CR::HSION::On::Set();
    
    while (RCC::CR::HSIRDY::NotReady::IsSet())
    {
      
    }
    
    RCC::CFGR::SW::Hsi::Set();
    while (!RCC::CFGR::SWS::Hsi::IsSet())
    {
      
    }
    
    RCC::APB2ENR::SYSCFGEN::Enable::Set();
    
    // Подключить таймер к системной частоте процессора
    STK::CTRL::CLKSOURCE::CpuClock::Set();
    
    return 1;
  }
  
}


void delay(std::uint32_t timeInMs)
{
  assert(timeInMs < 10000);
  // 1. Посчитать значение задержки
  const auto timerDelayCounts = (SystemCoreClock / 1000U) * timeInMs;
  // 2. Записать в регистре load значение задержки
  STK::LOAD::Write(timerDelayCounts - 1);
  // 3. Записать текущее значение задержки
  STK::VAL::Write(0);
  // 4. Включить системный таймер в регистре CTRL
  STK::CTRL::ENABLE::Enable::Set();
  
  // Дождаться готовности флага PENDSTSET в регистре ICSR - дождем конца задержки
  while(STK::CTRL::COUNTFLAG::NoOverflow::IsSet())    
  {    
  }    
  // 5. Отключить системный таймер в регистре CTRL
  STK::CTRL::ENABLE::Disable();
}


int main()
{  
  //Подать тактирование на порт А
  RCC::AHB1ENR::GPIOAEN::Enable::Set() ;
  //Подать тактирование на порт С
  RCC::AHB1ENR::GPIOCEN::Enable::Set() ;
  //Порта А.5 на вывод
  GPIOA::MODER::MODER5::Output::Set() ;
  //Порта C.5,C.8, C.9 на вывод
  GPIOC::MODER::MODER5::Output::Set() ;
  GPIOC::MODER::MODER8::Output::Set() ;
  GPIOC::MODER::MODER9::Output::Set() ;
  
  GPIOC::MODER::MODER13::Input::Set();
  
  Button<GPIOC, 13> button;
  
  Led<GPIOC, 5> led1;
  Led<GPIOC, 8> led2;
  Led<GPIOC, 9> led3;
  Led<GPIOA, 5> led4;
  
  tLeds leds = {
    &led1,
    &led2,
    &led3,
    &led4};
  
  
  ChessMode chessmode(leds);
  AllMode allmode(leds);
  TreeMode treemode(leds);
  
  tMode modes = {
    &chessmode,
    &allmode,
    &treemode
  };
  ModeManager modeManager(modes);
  modeManager.InitCurrentMode();
  
  for(;;)
  
  {
    modeManager.UpdateCurrentMode();
    if (button.IsPressed())
    {
      modeManager.SwitchMode();
    }
    delay(300);
  }
  
  return 1;
}
----

Таким образом, функция <<delay_func, *delay()*>> была настроена так, что на входе у нее - время в миллисекундах. Так, например, при написании delay(300) устанавливается задержка в 300 мс.

== Таймер TIM5

Таймер TIM5 является 32-битным (т.е. может считать до 2^32). Он может использоваться для:

* работы с инкрементальными энкодерами и датчиками Холла;
* синхронизации нескольких таймеров между собой;
* захвата сигнала (защелкивать значение, когда на выводе порта например 0 сменился на 1);
* Сравнения (считать до значения в регистре сравнения и установить/сбросить/переключить вывод порта);
* генерации ШИМ (генерировать прямоугольный сигнал с различной скважностью на вывод порта);
* генерации одиночного импульса.

Таймер TIM5 может генерировать следующие события:

* переполнение;
* захват сигнала;
* сравнение;
* событие-триггер.

=== Управление таймером TIM5

Таймер TIM5 тактируется от шины *APB1*. Так, например, если шина *APB1* работает на частоте 1 МГц, то один отсчет таймера произойдет через 1 мкс.

==== Регистры для режима счета

Для счета используются следующие регистры:

TIMx::CNT::
Cчетный 16/32 разрядный регистр таймера суммирующий, с приходом каждого тактового импульса инкрементирует свое содержимое.
На вычитание работать не может. ​

TIMx::PSC::
16 разрядный регистр - делитель частоты для таймера. Коэффициент деления задается в 16-разрядном регистре, этот
коэффициент можно задать в пределах от 1 до 65536.​

TIMx::ARR:: ​
16/32 разрядный регистр автоперезагрузки. В этот регистр записывается число, до которого будет идти счет. При достижении
этого значения, содержимое счетчика TIMx_CNT обнуляется и формируются прерывание или запрос DMA (если они разрешены).​

TIMx::SR:: ​
Регистр статуса. Можно узнать о всех возможных запросах на прерывания от таймера

==== Управляющий регистр CR1

Основные настройки таймера производятся регистром CR1.

.Управляющий регистр CR1
image::register_CR1.png[]

.Поля регистра CR1
[cols="a, a"]
|===
|Бит | Описание

|Bit 2: URS
|Источник генерации прерываний​

* *0*: Любые из следующих событий будут генерировать прерывание или запрос DMA, если они включены:​
** Переполнение счетчика​ или установлен UG бит​
* *1*: Только после переполнения счетчика может сгенерировать прерывание или запрос DMA​

|Bit 1: UDIS
|Отключить событие по изменению (Update Event)​

* *0*: UEV включен. Событие по изменению(UEV) генерируются следующими событиями:​
 ** Переполнение счетчика​ или установлен UG бит​
* *1*: UEV отключен. ​

|Bit 0 CEN
|Включить счетчик​

* *0*: Counter выключен​
* *1*: Counter включен​

|===

==== Регистр статуса SR

Регистр статуса SR хранит статусы запросов на прерывания

.Регистр статуса SR
image::register_SR.png[]

.Некоторые биты регистра SR
[cols="a, a"]
|===
|Бит | Описание

|Bit0: UIF
|Флаг прерывания по событию обновления. Бит устанавливается аппаратно, скидываться должен программно​

* *0*: Флаг прерывания сбршен​
* *1*: Флаг прерывания установлен​

|===

=== Алгоритм работы с таймером TIM5

Для того, чтобы использовать таймер TIM5 в качестве задержки, необходимо:

* Подать тактирование на модуль таймера​.
* Установить делитель частоты для таймера в регистре *PSC*​.
* Установить источник генерации прерываний по событию переполнение с помощью бита *URS* в регистре *CR1*​.
* Установить значение до которого счетчик будет считать в регистре перезагрузке *ARR*​.
* Скинуть флаг генерации прерывания *UIF* по событию в регистре *SR*​.
* Установить начальное значение счетчика в 0 в регистре *CNT*​.
* Запустить счетчик с помощью бита *EN* в регистре *CR1*​.
* Проверять пока не будет установлен флаг генерации прерывания по событию *UIF* в регистре *SR*​.
* Как только флаг установлен остановить счетчик, сбросить бит *EN* в регистре *CR1*, Сбросить флаг генерации прерывания.
*UIF* по событию в регистре *SR*.

=== Реализация алгоритма

Реализуем данный алгоритм, используя в качестве источника тактирования внутренний генератор 16 МГц.

[source,cpp]
----
#include "rccregisters.hpp" // for RCC
#include "gpioaregisters.hpp" // for GPIOA
#include  "gpiocregisters.hpp" // for GPIOС
#include "stkregisters.hpp" // for SystemTimer
#include "scbregisters.hpp" // for ISCR register
#include "tim5registers.hpp" // for TIM5

#include "Led.h"
#include "allMode.h"
#include "chessMode.h"
#include "treeMode.h"
#include "LedConfig.h"
#include "ModesConfig.h"
#include "Button.h"
#include "ModeManager.h"

std::uint32_t SystemCoreClock = 16'000'000U;

extern "C" {
  
  int __low_level_init(void)
  {    
    RCC::CR::HSION::On::Set();
    
    while (RCC::CR::HSIRDY::NotReady::IsSet())
    {  
    }
    
    RCC::CFGR::SW::Hsi::Set();
    while (!RCC::CFGR::SWS::Hsi::IsSet())
    {
    }
    
    // Подать тактирование на таймер
    RCC::APB1ENR::TIM5EN::Enable::Set();
    
    return 1;
  }
}


void delay(std::uint32_t timeInMs)
{
  assert(timeInMs < 10000);
  const auto prescalerValue = SystemCoreClock / 1000U - 1U;
  TIM5::PSC::Write(prescalerValue);
  TIM5::CR1::URS::Value1::Set(); 
  TIM5::ARR::Write(timeInMs);
  TIM5::SR::UIF::Set(0); 
  TIM5::CNT::Write(0); 
  TIM5::CR1::CEN::Enable::Set(); 
  while(TIM5::SR::UIF::NoInterruptPending::IsSet()) 
  {
  }
  TIM5::CR1::CEN::Disable::Set(); 
  TIM5::SR::UIF::Set(0); 
}


int main()
{  
  //Подать тактирование на порт А
  RCC::AHB1ENR::GPIOAEN::Enable::Set() ;
  //Подать тактирование на порт С
  RCC::AHB1ENR::GPIOCEN::Enable::Set() ;
  //Порта А.5 на вывод
  GPIOA::MODER::MODER5::Output::Set() ;
  //Порта C.5,C.8, C.9 на вывод
  GPIOC::MODER::MODER5::Output::Set() ;
  GPIOC::MODER::MODER8::Output::Set() ;
  GPIOC::MODER::MODER9::Output::Set() ;
  
  GPIOC::MODER::MODER13::Input::Set();
  
  Button<GPIOC, 13> button;
  
  Led<GPIOC, 5> led1;
  Led<GPIOC, 8> led2;
  Led<GPIOC, 9> led3;
  Led<GPIOA, 5> led4;
  
  tLeds leds = {
    &led1,
    &led2,
    &led3,
    &led4};
  
  
  ChessMode chessmode(leds);
  AllMode allmode(leds);
  TreeMode treemode(leds);
  
  tMode modes = {
    &chessmode,
    &allmode,
    &treemode
  };
  ModeManager modeManager(modes);
  modeManager.InitCurrentMode();
  
  for(;;)
    
  {
    modeManager.UpdateCurrentMode();
    if (button.IsPressed())
    {
      modeManager.SwitchMode();
    }
    delay(300);
  }
  
  return 1;
}
----

== Вывод

Таким образом, в ходе лабораторной работы была реализована функция задержки *delay()*
с помощью системного таймера *SysTick*, а также таймера общего назначения *TIM5*.