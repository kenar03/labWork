= Лабораторная работа №1
Долгов К.М. <КЭ-413>
:description: Лабораторная работа №1
:toc:
:toc-title: Оглавление
:figure-caption: Рисунок
:table-caption: Таблица
:imagesdir: images

== Процесс разработки ПО
Процесс разработки программного обеспечения включает в себя несколько этапов:

* Анализ требований

Анализ требований является самым важным этапом при разработке ПО. В ходе данного этапа определяются все требования, представленные заказчиком в ТЗ, а также уточняются некоторые аспекты ПО, о которых не было упомянуто в техническом задании, либо объяснение было не очевидным. Важность  этого этапа заключается в том, что при правильном понимании требований заказчика можно избежать множественных исправлений программы на поздних этапах разработки.

* Проектирование ПО

На этапе проектирования создается архитектура программного обеспечения, определяющая основные его компоненты и их взаимодействие друг с другом. Кроме того, на этапе проектирования выбираются технологии разработки, такие как среда разработки, а также язык программирования.

* Кодирование

Кодирование - это написание исходного кода ПО на выбранном языке программирования в соответствии с разработанной архитектурой. При условии, что этапы анализа требований и проектирования ПО были выполнены качественно, кодирование будет осуществлятся довольно просто.

* Тестирование

Заключительный этап разработки ПО - это тестирование. Оно позволяет првоерить работоспособность разработанных программ, а также исправляются ошибки.

== Компиляция кода, линковка и загрузка

Для того, чтобы исходный код программы можно было запускать на микроконтроллере, он должен быть преобразован соответствующим образом.

Обработка кода происходит в четыре этапа:

. препроцессинг;
. компиляция;
. компоновка (линковка);
. загрузка.

=== Препроцессинг

Самый первый этап сборки проекта - препроцессинг. Препроцессинг осуществляет программа, называемая препроцессором.

Препроцессор осуществляет предварительную обработку кода перед передачей его компилятору, а именно - обработку директив, которые в коде начинаются с символа #. Он выполняет следующие задачи:

* осуществляет обработку директив *#include*, добавляя в программу внешние библиотеки или другие зависимости;

* обрабатывает макросы *#define*, присваивая им заданные значения;

* осуществляет обработку директив типа *#ifdef*, *#endif*, которые позволяют исключать или наоборот, компилировать помещенные в директиву участки кода в зависимости от определенных условий;

* удаляет все написанные пользователем коментарии для того, чтобы облегчить последующий процесс компиляции.

После окончания препроцессинга начинается компиляция кода.

=== Компиляция

Компиляцию осуществляет компилятор. Он выполняет следующие задачи:

* проверяет код на корректность синтаксиса;

* если программа написана без ошибок, компилятор преобразует исходный код в объектные файлы (формат .o или .obj).

Кроме того, помимо объектных файлов компилятор способен формировать файлы библиотек, которые затем можно использовать в других программах.

=== Компоновка (линковка)

Далее сгенерированные объектные файлы (а также внешние библиотеки) и конфигурационный файл микроконтроллера, описывающий настройки по размещению кода и данных в адресном пространстве, с помощью линковщика объединяются друг с другом в единый файл (например, формата .elf или .hex). Сгенерированный файл и будет являтся прошивкой микроконтроллера.

=== Загрузка

Подготовленный файл прошивки (.elf или .hex) с помощью программатора загружается в ПЗУ микроконтроллера.

На рисунке ниже показан процесс сборки проекта в целом.

.Процесс сборки проекта
image::project_build.jpg[]

== Запуск кода на микроконтроллере

Действия пользователя, которые программна должна выполнять, описываются в функции main(). Однако, до начала выполнения данной функции микроконтроллер осуществляет следующие действия:

. инициализация стека;
. инициализация переменных;
. непосредственно вызов функции main().

=== Инициализация стека

Стек в микроконтроллерах - это область памяти, выделенная для запоминания адресов возврата из процедур обработки прерывания и подпрограмм. Иными словами, если в ходе работы программы возникло прерывание, то адрес, на котором это прерывание возникло, сохраняется в стек на время его обработки. По завершении обработки прерывания программа возвращается на адрес, записанный в стеке, и продолжает свое выполнение, а данный адрес из стека удаляется.


Стек заполняется от старших разрядов к младшим, а переполнение стека может привести к потере данных.

Процесс инициализации стека в микроконтроллере происходит следующим образом. После подачи питания на микроконтроллер регистр адреса команд указывает на нулевой адрес, на котором находится таблица векторов прерываний. По начальному векторы таблицы находится команда инициализации указателя стека на конечный адрес стека, т.е. таким образом происходит определение размера стека. После определения размера стека выполняется функция инициализации стека.

=== Инициализация переменных

Псоле того, как стек был инициализирован, начинается процесс инициализации переменных, который заключается в следующем.

Первым делом происходит инициализация переменных в нулевые значения. Этот процесс касается только тех переменных, которые не были проинициализированы пользователем (например, int variable). Таким переменным присваивается значение 0.

Затем происходит инициализация переменных, значения которых пользователь указал (например, int variable = 10). При этом значения инициализации для каждой переменной будут скопированы из ПЗУ в ОЗУ.

=== Вызов функции main()

Наконец, после инициализации стека и переменных вызывается функция main(), в которой написана основная программа микроконтроллера, созданная пользователем.

== Влияние размера стека на программу

Как было сказано ранее, стек в - это область памяти, выделенная для запоминания адресов возврата из процедур обработки прерывания и подпрограмм. Однако в стеке могут храниться не только адреса возврата, но и локальные переменные, используемые в функциях программы. Поэтому размер стека является очень важным показателем, и он должен выбираться с умом.

В случае, если размер стека недостаточен, может произойти его переполнение.

.Влияние переполнения стека на работу программы
image::stack_overflow.jpg[]

Одно из главных назначений стека - это хранение адресов возврата в те точки программы, где возникло прерывание. Если же стек переполнен, то постоянное добавление новых данных вызовет перезапись имеющейся в стеке информации, что может привести к изменению адресов возврата из прерываний. Изменение адресов возврата приведет к "поломке" программы. Кроме того, переполнение стека также может вызвать изменения хранящихся в нем локальных переменных.

Однако также нет смысла задавать стек слишком большого размера, так как в микроконтроллере память весьма ограничена, и излишне большой размер стека приведет к уменьшению памяти микроконтроллера, которая могла бы использоваться для хранения для других данных.

== Хранение переменных

Различают два вида памяти: ОЗУ и ПЗУ.

Если кратко, то ОЗУ предназначено для хранения тех даных, которые постоянно изменяются, а ПЗУ наоборот - для хранения неизменяемых данных.

Так, в ОЗУ существует область статической памяти, в которой хранятся *глобальные переменные* и другие данные. Главное отличие глобальные переменных от локальных заключается в том, что они существуют в течение всего времени выполнения программы, и поэтому им необходимо некоторое количество постоянно выделенной памяти. Однако следует учитывать, что область статической памяти - это абстрактное понятие, а области памяти задаются разработчиком в файле конфигурации. На рисунке ниже показан файл конфигурации линкера.

.Настройки линкера
image::linker_settings.jpg[]

Так, области памяти ОЗУ и ПЗУ могут быть заданы пользователем вручную, и может даже возникнуть ситуация, когда и стек, и переменные находятся в ПЗУ.

Локальные переменные используются только в тех функциях, в которых они были объявлены. Локальные переменные хранятся *в стеке*, поскольку после завершения выполнения функции они уничтожаются, и выделять под них память более не рационально.

Существуют также статические переменные, которые объявляются путем добавления ключевого слова *static*. Их отличие от обычных заключается в том, что область выделенной для них памяти неизменна. Статические переменные хранятся там же, где и глобальные - в ОЗУ.

Константы - это переменные, значение которых постоянно на все время действия программы. Они хранятся в ПЗУ.

== Компилятор и линкер

Как было сказано ранее, *компилятор* - это программа, которая преобразует исходный код программы, написанный на каком-либо языке программирования высокого уровня (например, C++), в машинный код, который может быть обработан микроконтроллером. Кроме того, компилятор проверяет написанный код на корректность написания (синтаксис).

"Переведенный" компилятором код затем преобразуется в объектные файлы (формат .o или .obj). Объектные файлы содержат машинный код, однако они должны быть обработаны в дальнейшем линковщиком.

Компилятор также может оптимизировать код. В IAR существует множество различных вариантов оптимизации. Так, со включенной оптимизацией компилятор может игнорировать части кода, не использующиеся при работе программы, упрощать и объединять выражения, для повторного расчета того же выражения использовать ранее полученный результат, а не считать заново и т.д. Настройки оптимизации компилятора IAR представлены на рисунке ниже.

.Настройки оптимизации компилятора IAR
image::compiler_optimization.jpg[]

Чем выше выбранный уровень оптимизации, тем больше "бесполезного" кода будет игнорироваться. Если же оптимизация отключена, то нерациональный код будет использован в программе полностью.

*Линкер* - это программа, которая объединяет созданные компилятором объектные файлы в единый исполняемый файл (формата .hex или .elf). Помимо объектных файлов, линкер также включает в исполняемый файл используемые библиотеки.

== Ответы на контрольные вопросы

[qanda]
Дайте определение понятию “Интегрированной среде разработки”::

Ответ: Интегрированная среда разработки - это комплекс средств, используемый для разработки нового программного обеспечения.

Что такое компилятор и чем он отличается от транслятора?::

Ответ: Компилятор - это программа, которая преобразует исходный код программы, написанный на каком-либо языке программирования высокого уровня (например, C++), в машинный код, который может быть обработан микроконтроллером. Он также осуществляет проверку кода на корректность написания. Результатом работы компилятора является создание объектных файлов, в которых содержится машинный код.
Транслятор - это программа, осуществляющая перевод кода с одного языка программирования на другой. Транслятор также осуществляет проверку синтаксиса. Отличие компилятора и транслятора заключается в том, что результатом работы компилятора являются объектные файлы, предназначенные для дальнейшего создания исполнительного файла. Транслятор же осуществляет конвертацию написанного кода в другой язык программирования, он не  предназначен для создания объектных файлов.

Что такое компоновщик и какие функции он выполняет?::
Ответ: Линкер (компоновщик) осуществляет сборку объектных файлов, созданных компилятором, и используемых в программе библиотек в единый исполняемый файл (формата .hex или .elf).

Почему важен процесс проектирования ПО. Какие задачи входят в этот процесс?::
Ответ: Процесс проектирования ПО является важным, так как при хорошо проведенном проектировании программа будет качественно исполнять поставленные перед ней задачи, а также ее будет легко поддерживать и развивать. Основные этапы проектирования ПО: анализ требований; разработка архитектуры; кодирование; тестировние.

Дорисуйте процесс разработки ПО, описанный на изображении Процесс разработки с точки зрения IAR Workbench с учетом итеративности связей в этом процессе.::
Ответ: -

Зачем нужна отладка и в каких случаях она применяется? Для чего применяются точки остановки?::
Ответ: Отладка представляет собой пошаговый процесс проверки работоспособности программы. Во время отладки разработчик может просматривать значения переменных, проверить содержимое памяти, стек, состояние регистров. Точка остановки - это заданная  вручную точка в программе, которую разработчик хочет проверить. На точке остановки программа приостанавливает свое выполнение на текущем этапе работы.

Какие еще важные характеристики IAR Workbench можно добавить в таблицу?::
Ответ: Другими важными характеристиками являются:
* Поддержка двух уровней языка C++: Embedded C++ (предназначен для программирования встраиваемых систем); IAR Extended Embedded C++ (обеспечивает полную поддержку шаблонов, пространства имен,  поддерживает множественное наследование, а также новые операторы типов).
* Поддержка различных типов ядер ARM и устройств, основанных на версиях ARM 4, 5, 6, 6M, 7.
* IAR имеет большой каталог файлов, созданных специально для поддерживаемых устройств.

== Выводы по работе

В ходе лабораторной работы на паре было изучено:

* Как создавать проект в IAR Workbench.

* Как откомпилировать и отлинковывать программу.

* Как проводить пошаговую отладку и устанавливать точки остановки.

* Что такое оптимизация компилятора и каким образом она влияет на ход работы программы.

* Что такое стек и каким образом его размер влияет на работу программы.